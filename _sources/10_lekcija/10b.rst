Конструкција elif
-----------------

Прикажимо употребу конструкције ``elif`` кроз следећи задатак.

Агрегатно стање воде
''''''''''''''''''''
.. level:: 2

.. questionnote::

   Напиши програм који за дату температуру воде (у степеним Целзијуса)
   одређује њено агрегатно стање (сматраћемо да је вода у чврстом
   стању ако јој је температура строго мања од 0, да је у течном ако
   јој је температура између 0 и 100 степени, укључујући и те границе
   и да је у гасовитом стању ако јој је температура строго већа од 100
   степени).

На основу услова задатка може се формирати програм у којем се помоћу
три провере услова независно проверава припадност температуре једном
од три интервала :math:`(-\infty , 0]`, :math:`(0, 100)` и
:math:`[100, \infty)`.

.. activecode:: агрегатно_стање_1

   temperatura = 15

   if temperatura < 0:
       stanje = "čvrsto"
   if temperatura >= 0 and temperatura <= 100:
       stanje = "tečno"
   if temperatura > 100:
       stanje = "gasovito"

Међутим, решење се може креирати и ако размишљамо на следећи начин
(тако да логички услови буду међусобно зависни):

- ако температура мања од :math:`0^{\circ}\,C` - агрегатно стање је
  чврсто;
- у противном (температура је већа или једнака :math:`0^{\circ}\,C`):
  ако је температура мања или једнака :math:`100^{\circ}\,C` (припада
  другом интервалу) - агрегатно стање je течно;
- у противном (температура је већа :math:`100^{\circ}\,C`) агрегатно
  стање је гасовито.

Такво постпуно проверавање услова се остварује помоћу **конструкције**
``elif``.
  
.. activecode:: агрегатно_стање_2
		
   temperatura = 15
   
   if temperatura < 0:
       stanje = "čvrsto"
   elif temperatura <= 100:
       stanje = "tečno"
   else:
       stanje = "gasovito"

   print(stanje)

У општем случају, општи облик ове конструкције је следећи:

.. activecode:: elif

   if uslov_1:
       naredbe
   elif uslov_2:
       naredbe
   ...
   elif uslov_k:
       naredbe
   else:
       naredbe

Прва група наредби се извршава ако је први услов испуњен, друга ако
први није испуњен а други јесте, трећа ако прва два услова нису
испуњена, а трећи јесте и тако даље, све до последње групе наредби
која се извршава ако ниједан од наведених услова није
испуњен. Приметимо да се увек извршава тачно један блок наредби у
наведеном коду.

Приметимо да је срж следећег задатка била у томе да се одреди којем од
неколико надовезаних интервала припада дата вредност (то су били
интервали :math:`(-\infty, 0)`, :math:`[0, 100]` и :math:`(100,
+\infty)`). Задаци тог облика су чести и када је таквих интервала
мало, обично се решавају конструкцијом ``elif``. И следећи задатак је
тог типа.

Број потеза краља
'''''''''''''''''
.. level:: 2
   
.. questionnote::

   Позиције на шаховској табли се обележавају, на пример, са ``a3``,
   ``b5``, ``h1`` и слично. Прво се наводи словна ознака колоне (од
   ``a`` до ``h``), а затим бројевна ознака врсте (од 1 до 8). Ако је
   дата позиција краља на шаховској табли на којој нема других фигура
   осим тог краља, напиши програм који одређује број потеза које тај
   краљ може да направи (краљ се у шаху може померити на било које
   њему суседно поље).

Постоје три различите врсте поља. Поља у угловима табле (поља ``a1``,
``a8``, ``h1`` и ``h8``) су таква да краљ може да се помери на само
три околне позиције. Поља која су на ивицама (у колонама ``a`` или
``h`` тј. у врстама ``1`` или ``8``), али нису у угловима су таква да
краљ може да се помери на пет околних позиција. Са осталих поља краљ
може да се помери на осам суседних позиција.
   
.. activecode:: краљ_број_потеза

   kralj = input("Unesi poziciju kralja:")
   kolona = kralj[0]
   vrsta  = kralj[1]
   kolona_na_ivici = kolona == "a" or kolona == "h"
   vrsta_na_ivici  = vrsta == "1" or vrsta == "8"
   if True:  # ispravi ovaj red
       broj_poteza = 3
   elif True:  # ispravi ovaj red
       broj_poteza = 5
   else:
       broj_poteza = 0   # ispravi ovaj red
   print(broj_poteza)      

Домаћи задатак
''''''''''''''

Ево и неколико задатака које можеш урадити за домаћи.


Килобајт
''''''''
.. level:: 1
      
.. questionnote::

   Напиши програм који проверава да ли је корисник научио колико
   бајтова постоји у једном килобајту.


.. activecode:: бајтова_у_килобајту

   odgovor = int(input("Koliko bajtova ima u jednom kilobajtu"))
   if True:  # popravi ovaj uslov
       print("Bravo")
   else:
       print("Odgovor nije tačan")

      
.. mchoice:: бајтова_у_килобајту_2
   :answer_a: odgovor == 1000
   :answer_b: odgovor = 1000
   :answer_c: odgovor == 1024
   :answer_d: odgovor = 1024
   :correct: c
   :feedback_a: Килобајт садржи 1024 бајта.
   :feedback_b: Килобајт садржи 1024 бајта, а поређење једнакости се записује
		коришћењем ==.
   :feedback_c: Браво!
   :feedback_d: Поређење једнакости се записује коришћењем ==.

   Који од наредних услова треба употребити у претходном програму?

Жупан или краљ
''''''''''''''
.. level:: 1
      
.. questionnote::       

   Стефан Немањић је био Велики жупан од 1196 до 1217, а краљ од 1217
   до 1228. Да ли је дуже владао као краљ или Велики жупан?

.. image:: ../../_images/stefan_nemanjic.jpg
   :align: center

.. activecode:: жупан_краљ

   zupan = 0   # ispravi ovaj red
   kralj = 0   # ispravi ovaj red
   if zupan < kralj:
   print("Дуже је био краљ.")     # ispravi ovaj red
   else:
   print("Дуже је био жупан.")    # ispravi ovaj red


Оцена на факултету
''''''''''''''''''
.. level:: 2

.. questionnote::

   На факултету се оцена одређује на основу броја поена на следећи
   начин. За 50 поена и мање добија се оцена 5, за поене од 51 до 60
   добија се оцена 6, од 61 до 70 оцена 7, од 71 до 80 оцена 8, од 81
   до 90 оцена 9 и за поене од 91 до 100 добија се оцена 10. Напиши
   програм који за дати број поена одређује оцену.

.. activecode:: оцена_на_основу_поена
		
   poeni = int(input("Unesi broj poena:"))
   
   if poeni < 51:
       ocena = 5
   elif True:      # ispravi ovaj red
       ocena = 6
   elif True:      # ispravi ovaj red
       ocena = 7
   elif poeni < 81:
       ocena = 0   # ispravi ovaj red
   elif True:      # ispravi ovaj red
       ocena = 9
   else:
       ocena = 0    # ispravi ovaj red

   print(ocena)

Рецимо и да смо овај задатак могли решити уз помоћ мало математике,
без гранања.
   
.. activecode:: оцена_на_основу_поена_без_гранања
		
   poeni = int(input("Unesi broj poena:"))
   ocena = (poeni - 1) // 10 + 1
   print(ocena)
            
Потези фигура у шаху
''''''''''''''''''''
.. level:: 3
   
.. questionnote::

   Краљ у шаху може да се помера само једно поље (на било које од
   могућих 8 суседних поља). Топ у шаху може да се помера вертикално
   или хоризонтално, било који број поља. Ловац у шаху може да се
   помера дијагонално, било који број поља. Краљица може да се помера
   хоризонтално, вертикално или дијагонално, било који број поља. Коњ
   се помера тако што иде два поља вертикално и једно поље
   хоризонтално или два поља хоризонтално и једно поље вертикално. Са
   сваку од описаних шаховских фигура дефиниши функцију која за дата
   два поља на шаховској табли (одређена својим координатама) одређује
   да ли фигура на празној табли може да стигне са првог на друго
   поље.

Први услов је да полазно поље мора бити различито од долазног. Ако су
дата поља са координатама ``(x1, y1)`` и ``(x2, y2)``, овај се услов
просто може проверити помоћу ``(x1, y1) != (x2, y2)``. Други начин не
користи парове и захтева да је бар једна од две координате различита
тј. да важи ``x1 != x2 or y1 != y2``.

Већина провера се може засновати на анализи хоризонталног и
вертикалног растојања између два поља. Када смо разматрали апсолутну
вредност рекли смо да се растојање између два броја може једноставно
израчунати као апсолутна вредност њихове разлике. Тако, , хоризонтално
растојање можемо одредити помоћу ``abs(x1 - x2)``, док вертикално
растојање можемо одредити помоћу ``abs(y1 - y2)``.

- Краљ се може померити ако је веће од ова два растојања једнако тачно
  1 (тада је растојање по једној координати 1, а по другој 0 или 1,
  што је тачно услов померања краља).
- Топ се може померити ако полазно и долазно поље имају исту
  координату ``x`` или исту координату ``y`` (обе координате не смеју
  бити једнаке јер би тада полазно и долазно поље било исто).
- Ловац се може померити ако два поља леже на истој дијагонали. Овај
  се критеријум може проверити тако што се утврди да је хоризонтално
  растојање између два поља једнако њиховом вертикалном растојању (у
  сваком дијагоналном кораку се та растојања умањују за 1, све док се
  не стигне до долазног поља када оба та растојања истовремено постају
  нула, што значи да су у почетку морала бити једнака).
- Проверу за краљицу можеш извршити тако што ћеш искомбиновати две већ
  направљене провере (ону за топа и ловца).
- На крају, проверу за коња можеш извршити тако што ћеш проверити да
  ли је хоризонтално растојање једнако 2, а вертикално 1 или је
  хоризонтално растојање једнако 1, а вертикално 2.

Имајући претходну анализу у виду, покушај да дефинишеш функције које
проверавају доступност поља. Када покренеш програм видећеш све потезе
које свака од фигура може да направи са датог поља, на основу чега ћеш
видети да ли је твоје решење исправно.

.. activecode:: шаховске_фигуре

   def kralj(x1, y1, x2, y2):
       return False

   def top(x1, y1, x2, y2):
       return False

   def lovac(x1, y1, x2, y2):
       return False

   def kraljica(x1, y1, x2, y2):
       return False

   def konj(x1, y1, x2, y2):
       return False

   polje = (3, 5)

   ====
   def ispisi_dostupna_polja(polje, naziv_figure, figura_provera):
       for x in range(1, 8+1):
	  for y in range(1, 8+1):
	     if (figura_provera(polje[0], polje[1], x, y)):
	        print(naziv_figure, x, y)

   ispisi_dostupna_polja(polje, 'kralj:', kralj)
   ispisi_dostupna_polja(polje, 'top:', top)
   ispisi_dostupna_polja(polje, 'lovac:', lovac)
   ispisi_dostupna_polja(polje, 'kraljica:', kraljica)
   ispisi_dostupna_polja(polje, 'konj:', konj)


.. reveal:: терен_тест_решење11
   :showtitle: Прикажи решење
   :hidetitle: Сакриј решење
   
   .. activecode:: шаховске_фигуре_решење

      def kralj(x1, y1, x2, y2):
          return max(abs(x1-x2), abs(y1-y2)) == 1

      def top(x1, y1, x2, y2):
          return (x1 == x2 or y1 == y2) and (x1, y1) != (x2, y2)

      def lovac(x1, y1, x2, y2):
          return abs(x1 - x2) == abs(y1 - y2) and (x1, y1) != (x2, y2)

      def kraljica(x1, y1, x2, y2):
          return top(x1, y1, x2, y2) or lovac(x1, y1, x2, y2)

      def konj(x1, y1, x2, y2):
          return ((abs(x1 - x2) == 2 and abs(y1 - y2) == 1) or \
                  (abs(x1 - x2) == 1 and abs(y1 - y2) == 2)) and \
	         (x1, y1) != (x2, y2)

      polje = (3, 5)
   
      ====
      def ispisi_dostupna_polja(polje, naziv_figure, figura_provera):
        for x in range(1, 8+1):
    	  for y in range(1, 8+1):
    	     if (figura_provera(polje[0], polje[1], x, y)):
    	        print(naziv_figure, x, y)
    
      ispisi_dostupna_polja(polje, 'kralj:', kralj)
      ispisi_dostupna_polja(polje, 'top:', top)
      ispisi_dostupna_polja(polje, 'lovac:', lovac)
      ispisi_dostupna_polja(polje, 'kraljica:', kraljica)
      ispisi_dostupna_polja(polje, 'konj:', konj)
	      
