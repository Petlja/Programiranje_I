25.1. Анимације
===============

Вероватно већ знаш да цртани филм настаје тако што се на екрану брзо
смењују сличице, при чему је свака следећа слика веома слична
претходној (ликови на слици су само мало померени у односу на
претходни положај).

На пример, од наредних осам сличица лика у различитим положајима:

.. image:: ../../_images/liktrci1.png
   :width: 120px
.. image:: ../../_images/liktrci2.png
   :width: 120px
.. image:: ../../_images/liktrci3.png
   :width: 120px
.. image:: ../../_images/liktrci4.png
   :width: 120px
.. image:: ../../_images/liktrci5.png
   :width: 120px
.. image:: ../../_images/liktrci6.png
   :width: 120px
.. image:: ../../_images/liktrci7.png
   :width: 120px
.. image:: ../../_images/liktrci8.png
   :width: 120px


настаје следећа анимација трчања:
           
.. image:: ../../_images/liktrci.gif
   :width: 120px
           
Анимације подразумевају брзу промену слике на екрану (на пример, 20
пута у секунди), обично у правилним временским интервалима (на пример,
на сваких 50 милисекунди). Свака тако кратко приказана слика назива се
*оквир* или *фрејм* анимације (енгл. *frame*). У овом делу приручника
видећемо како можемо направити програме у којима се приказују неке
анимације.

У програмима које смо до сада сретали слика се није мењала током
извршавања и цртање смо вршили само једном, пре главне петље програма
у којој смо чекали да корисник искључи прозор (у програмима заснованим
на библиотеци PyGameBg, та петља се остварује позивом функције
``pygamebg.wait_loop``).

У програмима са анимацијом цртање ћемо вршити обично унутар тела те
главне петље или, још боље, у засебној функцији коју ћемо на том месту
позивати (у програмима заснованим на библиотеци PyGameBg, таква петља
се остварује позивом функције ``pygamebg.frame_loop``).

Програмирање анимација на сајту "Петља"
---------------------------------------

Све анимације које ћемо у наставку приказати разликоваће се само по
томе који подаци одређују оно што се на слици налази, коду који
извршава цртање и коду који мења податке када се прелази на наредни
фрејм. Да бисмо ти олакшали сналажење са кодом који већ постаје
дугачак и компликован, цртање и прелазак са тренутног на наредни фрејм
ћемо издвојити у две помоћне функције које ти треба да напишеш, док
ћемо главну петљу програма која те две функције позива ми писати
уместо тебе (и она ће бити у "сивом делу кода"). Осим те две функције
твој задатак ће бити и да дефинишеш променљиве које описују оно што се
налази на екрану током анимације. То ће бити обично променљиве које
описују положај (координате) објеката тј. ликова који се током
анимације померају, њихову брзину, али и неки други подаци који се
мењају током анимације.

Прикажимо сада кроз неколико примера технику која ће вам олакшати
прављење анимација у примерима који следе. Сви ће бити засновани на
библиотеци PyGameBg, тако да ће и "сиви кôд" бити прилично
једноставан.

Посебна функција за цртање у програму без анимације
'''''''''''''''''''''''''''''''''''''''''''''''''''

За почетак прикажимо како се цртање може издвојити у посебну функцију
(и то прво у програму без анимација, а затим у програму са
анимацијама). Кренимо од програма који смо раније већ срели, који црта
три круга у разним бојама.

.. activecode:: tri_kruga
   :nocodelens:
   :modaloutput: 
   :enablecopy:
   :includesrc: _includes/tri_kruga.py

Цртање кругова је део главног програма. Исти ефекат можемо постићи ако
дефинишемо функцију ``crtaj`` коју ћемо позвати из главног програма.

.. activecode:: tri_kruga_funkcija
   :nocodelens:
   :modaloutput: 
   :enablecopy:
   :includesrc: _includes/tri_kruga_funkcija.py

Насумично одређивање боје позадине током анимације
''''''''''''''''''''''''''''''''''''''''''''''''''

Наредни програм ће приказивати једноставну анимацију у којој ћемо
четири пута у секунди на насумичан начин одређивати боју позадине.
Одређивање насумичне боје вршићемо помоћу посебне функције
`nasumicna_boja`.  Дефинисаћемо функцију `crtaj` у којој ће се
насумично одређивати боја и затим ће се позадина прозора бојити том
бојом. Пошто ћемо користити библиотеку *PyGameBg*, анимацију ћемо на
крају програма покретати позивом `pygamebg.frame_loop(4, crtaj)`, чиме
ћемо постићи да се функција `crtaj` аутоматски изнова позива 4 пута у
секунди.

.. activecode:: boja_pozadine_nasumicno_bez_stanja
   :nocodelens:
   :modaloutput: 
   :enablecopy:
   :includesrc: _includes/boje_pozadine_nasumicno_bez_stanja.py

                
Подијум за игру
'''''''''''''''

По истом принципу можемо прилагодити програм који је исцртавао подијум
за игру, тако да подијум стварно "оживи". Пронађи кôд који исцртава
подијум и на основу тога допуни функцију ``crtaj``.

.. activecode:: podijum_animacija
   :nocodelens:
   :modaloutput: 
   :enablecopy:
   :playtask:
   :includexsrc: _includes/podijum_animacije.py

   def nasumicna_boja():
       return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
    
   def crtaj():
       ???

                
Промена боје позадине у круг
''''''''''''''''''''''''''''
       
У многим анимацијама оно што се црта зависи од података који се мењају
током анимације. Променимо програм у ком се мења боја позадине екрана
тако да се боје не мењају насумично, него да се редом смењују црвена,
зелена и плава.

Најједноставнији начин да се задатак реши је да боје држимо у листи
(или торци) и да уз листу одржавамо и позицију текуће боје (њен индекс
у листи). Након коришћења боје са те позиције, позицију ћемо увећавати
за 1, при том пазећи да се након последње боје поново вратимо
на прву (да индекс постане 0). Најједноставнији начин да се то уради
је да се након увећавања индекса за 1 израчуна његов остатак при
дељењу са дужином листе (укупним бројем боја). Програм поново можемо
реализовати издвајањем цртања у помоћну функцију, која ће се током
анимације аутоматски позивати два пута у секунди.

.. activecode:: boje_pozadine_u_krug_samo_crtaj
   :nocodelens:
   :modaloutput: 
   :enablecopy:
   :includesrc: _includes/boje_pozadine_u_krug_samo_crtaj.py

Приметимо да кôд који се налази у функцији користи променљиве ``boje``
и ``broj_boje`` које су дефинисане ван функције. Такве променљиве се
називају *глобалне променљиве* и њихова се вредност може без икаквих
проблема очитати из функције. Међутим, промена вредности глобалних променљивих у
функцији је компликованија. Наиме, ако желимо да глобалној променљивој
променимо вредност у функцији, на почетку те функције морамо нагласити
да је та променљива глобална (помоћу кључне речи ``global`` иза које
следи листа глобалних променљивих, раздвојених запетама, којима ћемо у
тој функцији мењати вредност). Ако у функцији не бисмо навели реч
``global``, добили бисмо поруку о грешци.

::

   UnboundLocalError: local variable 'broj_boje' referenced before assignment

Нагласимо да глобалне променљиве нису најбољи начин за организовање
сложенијих програма и постоје бољи начини да се подаци организују,
међутим, у кратким програмима какве ћемо ми писати глобалне променљиве
представљају најједноставније решење и стога ћемо их у наставку
користити.

Функција ``crtaj`` је у претходном програму извршавала два
задатка. Једно је цртање сцене на основу тренутних вредности глобалних
променљивих, а друго је промена вредности променљивих чиме се са
текућег прелази на наредни фрејм. И наредни програми са анимацијама ће
имати те две функционалности, па програм постаје лепши ако их
раздвојимо у две функције (иако овај корак можда делује сувишан код
овако кратких програма, код дужих програма ће бити веома корисно да
поступак цртања одвојимо од поступка измене стања програма).

.. activecode:: boje_pozadine_u_krug
   :nocodelens:
   :modaloutput: 
   :enablecopy:
   :includesrc: _includes/boje_pozadine_u_krug.py

Анализирајмо још једном претходни пример.

- Стање програма је једнозначно одређено глобалном целобројном
  променљивом ``broj_boje`` која одређује редни број боје којом се
  прозор боји. Почетна вредност ове променљиве је нула, што значи да
  боје крећу да се приказују од почетка листе. Боје су смештене у
  глобалној листи ``boje`` која се не мења током извршавања програма.
- Функција ``crtaj`` боји прозор бојом, одређеном вредношћу променљиве
  ``broj_boje``.
- Функција ``novi_frejm`` ажурира вредност стања тј. променљиве
  ``broj_boje`` тако што јој увећава вредност и враћа је на нулу када
  вредност достигне укупан број боја. Пошто се мења вредност
  променљиве ``broj_boje`` која је глобална, у функцији ``novi_frejm``
  морамо да променљиву ``broj_boje`` означимо помоћу кључне речи
  ``global``.
                
Сви програми са анимацијама које ћемо у наставку писати биће
организовани на овај начин и твој задатак ће бити да дефинишеш
променљиве које одређују стање сцене и функције ``crtaj`` и
``novi_frejm``. На пример, програм који насумично мења боју позадине
можемо написати на следећи начин.

.. activecode:: boje_pozadine_nasumicno
   :nocodelens:
   :modaloutput: 
   :enablecopy:
   :includesrc: _includes/boje_pozadine_nasumicno.py

Анализирајмо још једном претходни пример.

- Стање програма је једнозначно одређено глобалном целобројном
  променљивом ``boja`` која одређује тренутну боју позадине
  екрана. Почетна вредност ове променљиве се одређује насумично.
- Функција ``crtaj`` боји прозор бојом одређеном вредношћу променљиве
  ``boja``.
- Функција ``novi_frejm`` ажурира стање тј. променљиву
  ``boja`` тако што јој насумично додељује нову вредност. Пошто се
  мења вредност променљиве ``boja`` која је глобална, у функцији
  ``novi_frejm`` морамо да променљиву ``boja`` означимо помоћу кључне
  речи ``global``. Ова се функција позива аутоматски у правилним
  временским итервалима и након ажурирања променљивих она позива
  функцију ``crtaj`` да би се прозор поново исцртао.

Општи облик програма са анимацијама
-----------------------------------

Видели смо неколико примера и можеш приметити да смо у свима њима
анимације остваривали по истом принципу, који ћеш ти примењивати и у
наредним задацима.

1. Потребно је да дефинишеш глобалне променљиве којима се
представљају подаци о ликовима и објектима на сцени (ти ће се подаци
мењати током анимације).

2. Потребно је да дефинишеш функцију ``crtaj`` која коришћењем тих
података црта сцену. У тој функцији нећемо вршити никакву промену
података.

3. Потребно је да дефинишеш функцију ``novi_frejm`` која ажурира
податке о ликовима и објектима на сцени (при чему све променљиве
којима се у тој функцији мења вредност морају на њеном почетку бити
експлицитно означене као глобалне коришћењем кључне речи ``global``).
Након ажурирања променљивих, потребно је да у функцији ``novi_frejm`` позовеш функцију
``crtaj``, да би се промењена сцена исцртала.


.. topic:: Погледај видео:

   У овом видеу погледај мало детаљније свео  чему је било речи у овом поглављу

    .. ytpopup:: aW9PBGgeug
        :width: 735
        :height: 415
        :align: center  