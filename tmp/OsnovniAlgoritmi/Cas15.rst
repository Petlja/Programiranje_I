Час 15 - Основни алгоритми - сабирање, бројање, множење, минимум, максимум
##########################################################################
  
У наставку ћемо научити неколико основних алгоритама. Већину њих
Python већ подржава у облику уграђених функција (које смо већ раније
разматрали) и њих је заправо најчешће боље користити него их изнова
програмирати. Са друге стране, учењем ових основних алгоритама учимо
се процесу програмирања и учимо се да размишљамо алгоритамски. Иако
смо целу ову област обележили као мало напреднију, ако кренеш да је
истражујеш, приметићеш да постоје алгоритми за које смо сигурни да ћеш
веома једноставно да их разумеш и научиш.
  
Сабирање
--------

Обим многоугла
''''''''''''''

.. questionnote::

   Напиши програм у коме се прво уноси број страница многоугла, затим
   се уносе дужине једне по једне странице и на крају се исписује обим
   тог многоугла.

Циљ овог задатка је да нас уведе у различите технике израчунавања
збира неколико бројева. Да бисмо једноставније разумели технику која
се користи за израчунавање збира бројева, олакшајмо мало задатак тако
што ћемо уместо обима многоугла израчунавати обим троугла. Директан
начин да се то уради је следећи:

.. activecode:: обим_1

   a = int(input("Unesi dužinu stranice:"))
   b = int(input("Unesi dužinu stranice:"))
   c = int(input("Unesi dužinu stranice:"))
   obim = a + b + c
   print(obim)

Прво смо учитали сва три броја (зато су нам биле потребне три
променљиве) и тек онда смо израчунали обим. Овај начин није директно
применљив на случај многоугла јер не знамо колико ће нам променљивих
бити потребно (чак иако знамо, њих може бити пуно и такав програм би
био непотребно дугачак).

Други начин израчунавања обима троугла ће бити такав да ћемо мењати
вредност збира након сваког учитавања дужине странице. У првом кораку
поставићемо вредност збира (обима) на прву учитану вредност, а у
сваком следећем кораку увећаваћемо текућу вредност збира за вредност
учитану у том кораку (подсетимо се, вредности променљивих се могу
мењати током извршавања програма).

.. activecode:: обим_2

   d = int(input("Unesi dužinu stranice:"))
   obim = d
   d = int(input("Unesi dužinu stranice:"))
   obim = obim + d
   d = int(input("Unesi dužinu stranice:"))
   obim = obim + d
   print(obim)

Ако извршимо претходни програм корак-по-корак, можемо приметити да у
првом кораку променљива ``obim`` има вредност дужине прве странице, у
другом збира дужина прве и друге странице, а да у трећем збира дужина
све три странице.
   
Приметимо да су други и трећи корак једнаки и могу се извршити у петљи.

.. activecode:: обим_3

   d = int(input("Unesi dužinu stranice:"))
   obim = d
   for i in range(2):
       d = int(input("Unesi dužinu stranice:"))
       obim = obim + d
   print(obim)

Програм додатно можемо поједноставити ако и први корак сведемо на
облик у којем су друга два и њега убацимо у петљу. Зато приметимо да
важи да је :math:`a + b + c = ((0 + a) + b) + c` (нула је сабирак који
не утиче на вредност збира - каже се да је нула *неутрални елемент*
приликом сабирања). Збир се, дакле, може на почетку поставити (кажемо
*иницијализовати*) на нулу, и затим се на њега може додавати један по
један сабирак. Кажемо са се у сваком кораку збир *ажурира*.
   
.. activecode:: обим_4
   
   obim = 0
   d = int(input("Unesi dužinu stranice:"))
   obim = obim + d
   d = int(input("Unesi dužinu stranice:"))
   obim = obim + d
   d = int(input("Unesi dužinu stranice:"))
   obim = obim + d
   print(obim)

Претходни програм се може једноставније реализовати уз помоћ петље:
   
.. activecode:: обим_5

   obim = 0
   for i in range(3):
       d = int(input("Unesi dužinu stranice:"))
       obim = obim + d
   print(obim)

Напокон, овај програм можемо веома једноставно уопштити тако да ради и
за многоуглове.

.. activecode:: обим_6

   n = int(input("Unesi broj stranica mnogougla:"))
   obim = 0
   for i in range(n):
       d = int(input("Unesi dužinu stranice:"))
       obim = obim + d
   print(obim)

.. infonote::

   Каже се да је овај програм заснован на шаблону који се некада
   називa *акумулатор*, *редукција* или *fold* и видећемо га у разним
   алгоритмима који следе.  Заснива се на томе да се променљива која
   треба да садржи коначан резултат иницијализује на неку вредност, а
   затим да се у сваком кораку петље ажурира и нова вредност јој се
   израчуна на основу њене тренутне вредности и тренутног елемента
   серије која се обрађује. У нашем примеру променљива која израчунава
   збир се иницијализује на нулу, а у сваком кораку нова вредност јој
   се израчунава тако што се на претходну вредност збира дода нови
   сабирак. Приметимо да и пре петље и током извршавања петље и након
   петље променљива садржи тачно збир свих до тада учитаних елемената
   серије тј. свих до тада учитаних дужина странице многоугла.

Укупан рачун
''''''''''''
   
.. questionnote::

   Ако је позната листа цена производа у корпи израчуна укупан рачун.

Овај задатак смо већ разматрали када смо причали о уграђеним
функцијама за рад са листама, међу којима се налазила и функција
``sum`` која служи за израчунавање збира елемената листе.

.. activecode:: цене_1

   cene = [45.95, 27.50, 34.75, 91.25]
   print(sum(cene))

Међутим, на овом месту желимо да прикажемо да се збир може израчунати
и применом алгоритма сабирања. Модификуј наредни програм тако да
исправно израчуна укупну цену.
   
.. activecode:: цене_2

   cene = [45.95, 27.50, 34.75, 91.25]
   ukupno =                          # dopuni ovaj red 
   for cena in cene:
       ukupno =                      # dopuni ovaj red
   print(ukupno)

Укупан број лоптица испред Карела
'''''''''''''''''''''''''''''''''

.. questionnote::

   Карел се налази испред пуно лоптица и жели да израчуна њихов укупан
   број. Сваки пут када се робот покрене, испред њега се лоптице
   распореде другачије. На сваком пољу је написан број лоптица на
   њему. Када је Карел на том пољу он број лоптица може сазнати
   позивом функције ``broj_loptica_na_polju()``. Карел тренутно само изговара
   број лоптица на сваком пољу.  Поправи програм тако да се исправно
   израчунава укупан број лоптица.
   
.. karel:: карел_сабира

   
   {
      setup: function() {

           function random(n) {
              return Math.floor(n * Math.random());
	   }
      
	   var world = new World(6, 1);
           world.setRobotStartAvenue(1);
           world.setRobotStartStreet(1);
           world.setRobotStartDirection("E");
	   for (var k = 2; k <= 6; k++)
	          for (var c = 0; c < random(10); c++)
                     world.putBall(k, 1);
           var robot = new Robot();
	   robot.setInfiniteBalls(true);
	   
	   var code = ["from karel import *",
	                   "broj = 0",
			   "while moze_napred():",
			   "    napred()",
			   "    # zameni narednu liniju tako da se azurira brojac loptica",
			   "    izgovori(broj_loptica_na_polju())",
			   "izgovori(broj)"];
	   return {world: world, robot: robot, code: code};
      },

      isSuccess: function(robot, world) {
           var broj = 0;
	   for (var k = 2; k <= 6; k++)
	      broj += world.getBalls(k, 1);
	   console.log(broj, robot.lastMessage);
           return broj == parseInt(robot.lastMessage);
      }
   }

Да резимирамо, збир серије бројева се може израчунати тако што се
променљива иницијализује на нулу, а затим јој се додаје један по један
елемент серије.
   
Бројање
-------

Број елемената у листи
''''''''''''''''''''''

.. questionnote::

   Напиши програм који израчунава број елемената листе.

Ко је добро научио лекцију о листама вероватно се сећа да се дужина
листе може (и треба) израчунати помоћу уграђене функције
``len``. Међутим, кроз овај задатак желимо да прикажемо алгоритам
бројања. На почетку петље бројач елемената иницијализоваћемо на нулу,
а онда ћемо у сваком кораку петље која пролази кроз елементе листе
бројач увећавати за један.

.. activecode:: дужина_листе

   a = [3, 7, 4, 2, 1, 6]
   duzina = 0
   for x in a:
       duzina = duzina + 1
   print(duzina)

Приметимо сличност са алгоритмом сабирања (једина разлика је то што се
уместо увећавања збира за вредност текућег елемента бројач увећава за
један).

Број унетих имена
'''''''''''''''''

.. questionnote::

   Напиши програм који уноси имена ученика све док се не унесе празна ниска
   и на крају пријављује колико имена је унето.

Пробај да допуниш наредни програм тако да коректно броји унета имена.

.. activecode:: бројање

   broj =      # dopuni ovaj red
   while input("Kako se zoveš?") != "":
       broj =    # dopuni ovaj red
   print("Broj prijavljenih:", broj)


Број корака до зида
'''''''''''''''''''
   
.. questionnote::

   Карел се налази на почетку лавиринта и занима га колико је корака
   потребно да направи да би стигао до зида. Напиши програм који му у
   томе помаже.

   Сваки пут када се помери напред, Карел треба да увећа бројач за један.
   
.. karel:: карел_broji
   
   {
      setup: function() {
           function random(n) {
              return Math.floor(n * Math.random());
	   }

           var dim = 3 + random(3);
	   var world = new World(dim, 1);
           world.setRobotStartAvenue(1);
           world.setRobotStartStreet(1);
           world.setRobotStartDirection("E");
           var robot = new Robot();
	   
	   var code = ["from karel import *",
	                   "broj = 0",
			   "while moze_napred():",
			   "    napred()",
			   "    # dodaj liniju kojom se ažurira brojač",
			   "izgovori(broj)"];
	   return {world: world, robot: robot, code: code};
      },

      isSuccess: function(robot, world) {
           return world.getAvenues() == parseInt(robot.lastMessage) + 1;
      }
   }

Просечна температура
''''''''''''''''''''

.. questionnote::

   Напиши програм који израчунава просечну температуру ако је дата
   листа која садржи температуре сваког дана током неког периода.

Подсетимо се просечна вредност елемената листе може одредити тако што
се збир свих елемената листе подели бројем елемената те
листе. Најлакши и најбољи начин да се то уради је да се употребе
уграђене функције ``sum`` и ``len``.

.. activecode:: просечна_температура_1

   temperature = [25, 24, 22, 17, 21, 23]
   print(sum(temperature) / len(temperature))

Међутим, вежбе ради, хајде да урадимо овај задатак без примене
уграђених функција, комбиновањем алгоритама сабирања и
бројања. Приметимо да можемо у једној петљи проћи кроз елементе листе
и истовремено рачунати и збир и број елемената листе.

.. activecode:: просечна_температура_2

   temperature = [25, 24, 22, 17, 21, 23]
   zbir = 0
   broj = 0
   for temperatura in temperature:
       zbir = zbir + temperatura
       broj = broj + 1
   print(zbir / broj)


Множење
-------

Запремина квадра
''''''''''''''''

.. questionnote::

   Напиши програм који израчунава запремину квадра чије се дужине
   страница уносе (запремина квадра једнака је производу дужина његове
   три странице).

Овај задатак је веома сличан оном у којем се израчунавао обим троугла,
једино што се уместо збира три броја захтева израчунавање производа
три броја. Директно решење је зато веома слично:
   
.. activecode:: запремина_1
   
   a = int(input("Unesi dužinu stranice:"))
   b = int(input("Unesi dužinu stranice:"))
   c = int(input("Unesi dužinu stranice:"))
   zapremina = a * b * c
   print(zapremina)

И у овом случају желимо да стигнемо до решења у којем се бројеви
учитавају и обрађују у петљи, како бисмо касније могли да га уопштимо
и применимо на проблем проналажења производа више бројева. Производ се
може поступно израчунавати тако што се помноже прво прва два броја, па
се затим добијени производ помножи трећим бројем. Заиста, важи да је
:math:`а \cdot b \cdot c = (a \cdot b) \cdot c`. Међутим, и у овом
случају желимо да сва три броја обрађујемо на исти начин. Ако бисмо
производ иницијализовали на нулу, он би до краја остао једнак нули јер
важи да је :math:`((0 \cdot a) \cdot b) \cdot c = 0`. Међутим, ако
производ иницијализујемо на један, добијамо тачно оно што нам треба
(јер важи да је :math:`а \cdot b \cdot c = ((1 \cdot a) \cdot b) \cdot
c`). Као што је нула био број који не утиче на сабирање (који је
неутрални елемент за сабирање), тако је један број који не утиче на
множење (он је неутрални елемент за множење). Дакле, програм за
израчунавање запремине, тј. производа три унета броја се може
дефинисати на следећи начин.

.. activecode:: запремина_2

   zapremina = 1
   d = int(input("Unesi dužinu stranice:"))
   zapremina = zapremina * d
   d = int(input("Unesi dužinu stranice:"))
   zapremina = zapremina * d
   d = int(input("Unesi dužinu stranice:"))
   zapremina = zapremina * d
   print(zapremina)

Пошто се исте наредбе понављају три пута, још је боље решење да се
употреби петља.
		
.. activecode:: запремина_3

   zapremina = 1
   for i in range(3):
       d = int(input("Unesi dužinu stranice:"))
       zapremina = zapremina * d
   print(zapremina)

Дакле, производ можемо израчунати тако што се његова вредност у
почетку иницијализује на 1, а затим ажурира тако што се у сваком
кораку множи текућом вредношћу.

.. infonote::

   Приметимо изузетну сличност алгоритма израчунавања збира и
   алгоритма израчунавања производа. Једина разлика је то што се у
   иницијализацији збир иницијализује на нулу, а производ на јединицу
   и то што се током ажурирања збира користи сабирање тј. оператор
   ``+``, а током ажурирања производа користи множење тј. оператор
   ``*``. Приметимо да и овај алгоритам користи шаблон акумулатор.

Степеновање
'''''''''''
   
.. questionnote::

   Када је :math:`n` природан број, производ бројева :math:`n \cdot x`
   означава збир који садржи :math:`n` сабирака :math:`x` тј. збир
   :math:`\underbrace{x + \ldots + x}_n`. Слично се може посматрати
   производ који садржи :math:`n` чинилаца :math:`x` тј. производ
   :math:`\underbrace{x \cdot \ldots \cdot x}_n`. У математици се
   такав производ назива *степен* и обележава се са :math:`x^n`. Тако
   је, на пример, :math:`2^4 = 2 \cdot 2 \cdot 2 \cdot 2 =
   16`. Дефиниши функцију која за дате параметре :math:`x` и :math:`n`
   израчунава :math:`x^n`.

Рецимо да Python подржава директно операцију степеновања и она се
изражава оператором ``**`` и тражени степен се може једноставно
изразити помоћу ``x ** n``. Ипак, вежбе ради, желимо да степен
дефинишемо применом алгоритма множења.
	 
.. activecode:: степен

   def stepen(x, n):
       s =                   # допуни овај ред
       for i in range(n):
           s =               # допуни овај ред
       return s

   ====
   from unittest.gui import TestCaseGui

   class myTests(TestCaseGui):

       def testOne(self):
          self.assertEqual(stepen(2, 10), 1024, "2 ** 10 == 1024")
          self.assertEqual(stepen(3, 3), 27, "3 ** 3 == 27")
          self.assertEqual(stepen(4, 0), 1, "4 ** 0 == 1")
          self.assertEqual(stepen(1.5, 2), 2.25, "1.5 ** 2 == 2.25")

   myTests().main()


Пшеница на шаховској табли
''''''''''''''''''''''''''
.. level:: 2

.. questionnote::

   Легенда каже да је изумитељ игре шах од свог владара тражио да га
   награди тако што ће на прво поље шаховске табле ставити једно зрно
   пшенице, на друго два зрна, на треће четири и тако даље, стављајући
   на свако поље дупло више зрна пшенице него на претходно. Владар се
   насмејао како је малу награду изумитељ тражио, међутим, када је
   кренуо да броји зрна, брзо је схватио да у целом краљевству нема
   довољно пшенице да би исплатио награду. Напиши програм који
   исписује колико на сваком од поља има зрна пшенице, као и колико је
   укупно пшенице на целој табли.
   
   
Током рада програма одржаваћемо променљиву која чува број зрна на
тренутном пољу (њена вредност креће од 1 и у сваком кораку се увећава
за 2) и укупан број зрна на пољима до тог (њена вредност креће од 0 и
у сваком кораку се увећава за број зрна на текућем пољу). Тело петље у
којем се исписује број зрна на текућем пољу и у којој се ажурирају
вредности променљивих (израчунава се њихова нова вредност) поновићемо
64 пута.
	   
.. activecode:: пшеница_и_шах

   ukupno_zrna = 0		
   broj_zrna = 1
   for polje in range(64):
       print(broj_zrna)
       ukupno_zrna = ukupno_zrna + broj_zrna
       broj_zrna = broj_zrna * 2
   print("Ukupno: ", ukupno_zrna)

Обавезно изврши овај програм корак по корак и посматрај како се у
сваком кораку петље мењају вредности променљивих.
   
Факторијел
''''''''''
   
.. questionnote::

   Напиши пограм који израчунава на колико начина се :math:`n` деце
   може распоредити на :math:`n` столица.

Једно дете може на једну столицу сести само на један начин. Двоје деце
може на две столице сести на два начина: прво дете на прву столицу,
друго на другу или друго дете на прву столицу, а прво на
другу. Обележимо ове начине са 12 и 21. Три детета могу сести на три
столице на шест начина: 123, 132, 213, 231, 312, 321. На пример,
распоред 231 означава да друго дете седи на првој столици, треће на
другој, а прво дете на првој столици. Размотримо како у општем случају
можемо израчунати број начина. На прву столицу може да седне било које
од :math:`n` деце. Након тога остаје :math:`n-1` дете и исто толико
столица, па на другу столицу може стати било које од те деце. На трећу
столицу може сести било које од преостала :math:`n-2` детета и тако
даље, све док на последњу столицу не седне последње преостало
дете. Зато је број начина једнак је производу бројева :math:`n`,
:math:`n-1`, :math:`n-2` итд. све до :math:`1`, тј. производу
:math:`n\cdot(n-1)\cdot(n-2)\cdot \ldots 2\cdot 1`. Тај производ се у
математици често јавља, па има посебно име и ознаку - обележава се са
:math:`n!`, а назива *факторијел броја* :math:`n`.

Дакле, овај број можемо решити тако што израчунамо производ свих
бројева од :math:`1` до :math:`n`.
      
.. activecode:: факторијел

   faktorijel = 1
   for i in range(1, n):
      faktorijel = faktorijel * i
   print(faktorijel)		

                
Минимум, максимум
-----------------

Размотримо сада проблем одређивања највећег или најмањег елемената
између неколико датих бројева. Један начин да се то уради је коришћење
уграђене функције ``min`` тј. ``max`` за одређивање минимума
тј. максимума листе бројева.

Највиши од четири другара
'''''''''''''''''''''''''

.. questionnote::

   Ако су познате висине четири другара, одреди висину највишег од њих.

Решење засновано на листама и функцији за рачунање максимума листе смо
већ раније видели.

.. activecode:: највећа_висина_1

   visine = [173, 171, 184, 177]
   najvisi = max(visine)
   print(najvisi)

У наставкућемо видети како да ово постигнемо и без листа и уграђених
функција. Функција ``max`` се може применити на листу, међутим, могуће
је применити и на више бројева. Тако смо задатак могли решити и без
коришћења листе.
   
.. activecode:: највећа_висина_2

   najvisi = max(173, 171, 184, 177)
   print(najvisi)

Често програмски језици нуде само функцију за одређивање већег
тј. мањег од два задата броја (није јој могуће навести више од два
аргумента). Максимум више бројева се може свести на узастопну примену
ове функције.
   
.. activecode:: највећа_висина_3

   najvisi = max(max(max(173, 171), 184), 177)
   print(najvisi)

Приметимо да смо и збир више бројева рачунали тако што смо узастопно
примењивали операцију сабирања два броја. Тако је збир ``a + b + c +
d`` рачунат као ``((a + b) + c) + d``, тј. као ``zbir(zbir(zbir(a, b),
c), d)``. Ово нам указује на то да и максимум више бројева можемо
израчунати на сличан начин на који смо рачунали збир - максимум
иницијализујемо на први елемент и онда га у сваком наредном кораку
ажурирамо на већу вредност од досадашњег максимума и текућег елемента.
   
.. activecode:: највећа_висина_4

   najvisi = 173
   najvisi = max(najvisi, 171)
   najvisi = max(najvisi, 184)
   najvisi = max(najvisi, 177)
   print(najvisi)

Изврши претходни програм корак по корак, и прати како се мења вредност
променљиве ``najvisi``.

Ако се елементи налазе у листи или се учитавају са улаза, онда можемо
да употребимо и петље.
   
.. activecode:: највећа_висина_5

   visine = [173, 171, 184, 177]
   najvisi = visine[0]
   for i in range(1, len(visine)):
       najvisi = max(najvisi, visine[i])

Програм можемо да уопштимо и на већи број особа.     

.. activecode:: највећа_висина_6

   n = int(parse("Унеси број особа:"))		
   najvisi = int(parse("Унеси висину:))
   for i in range(1, n):
       najvisi = max(najvisi, int(parse("Унеси висину:)))

У оба случаја први елемент је обрађиван пре петље, различито од свих
осталих. У програму у којем смо рачунали збир и производ, видели смо
да све елементе можемо да обрађујемо на исти начин ако за почетну
вредност узмемо 0, тј. 1, јер су то вредности које не утичу на збир
(рекли смо да се такве вредности називају неутралним). Наиме, важи да
је :math:`a + b + c = ((0 + a) + b) + c` тј. да је ``zbir(zbir(a, b),
c)`` исто што и ``zbir(zbir(zbir(0, a), b), c)``, зато што за било
који број ``a`` важи да је ``zbir(a, 0)`` једнак ``a``. Питање је да
ли нешто слично можемо да урадимо и за минимум тј. максимум. Потребно
је да пронађемо вредност ``x`` тако да за било који број ``a`` важи да
је ``max(x, a) = a``, тј. број који је мањи или једнак било ком другом
броју. То је у општем случају број минус бесконачно :math:`-\infty`,
међутим, њега не умемо да запишемо у програму. Ако знамо да међу
бројевима чији ћемо максимум рачунати неће бити бити негативних, онда
за почетну вредност можемо узети нулу јер у том случају важи да је
``max(max(a, b), c) = max(max(max(0, a), b), c)``.
     
.. activecode:: највећа_висина_7

   visine = [173, 171, 184, 177]
   najvisi = 0
   najvisi = max(najvisi, visine[0])
   najvisi = max(najvisi, visine[1])
   najvisi = max(najvisi, visine[2])
   najvisi = max(najvisi, visine[3])

.. activecode::  највећа_висина_8

   visine = [173, 171, 184, 177]
   najvisi = 0
   for visina in visine:
       najvisi = max(najvisi, visina)
   print(najvisi)
   
Слично, ако знамо да ће сви бројеви чији максимум рачунамо бити већи
или једнаки неком броју ``x`` за почетну вредност можемо узети тај
број (или било који број мањи од њега).
   
Када рачунамо минимум, за почетну вредност треба да узмемо вредност
која је већа или једнака било ком другом броју, а то је вредност плус
бесконачно :math:`+\infty`. Ако знамо да су сви бројеви чији минимум
рачунамо мањи или једнаки неком броју ``x`` за почетну вредност можемо
узети тај број (или било који број већи од њега).

Проналажење максимума тј. минимума може се реализовати и без употребе
функције ``max`` тј. ``min``. Функцију која рачуна већи од два броја
можемо једноставно реализовати коришћењем гранања.

.. activecode:: максимум

   def max(a, b):
       if a > b:
           return a
       else:
           return b

Ако то узмемо у обзир тада ``najvisi = max(visina, najvisi)`` можемо
заменити следећом наредбом гранања.
      
.. activecode:: висина_максимум
		
     if visina > najvisi:
         najvisi = visina
     else:
         najvisi = najvisi

Лако се примећује да je наредба гранања сувишна (јер не производи
никакав видљив ефекат).
	
.. activecode:: висина_максимум_1
		
     if visina > najvisi:
         najvisi = visina

Тако се највећа висина може наћи на следећи начин, без употребе
функције ``max`` (пошто знамо да су све висине позитивне, максимум
иницијализујемо на нулу).
	
.. activecode:: највећа_висина_9

   visine = [173, 171, 184, 177]
   najvisi = 0
   for visina in visine:
       if visina > najvisi:
           najvisi = visina
   print(najvisi)

Слично можемо израчунати и најмању висину (минимум ћемо
иницијализовати на први елемент листе).
   
.. activecode:: најмања_висина_1

   visine = [173, 171, 184, 177]
   najnizi = visine[0]
   for visina in visine[1:]:
       najnizi = min(najnizi, visina)
   print(najnizi)

.. activecode:: најмања_висина_2

   visine = [173, 171, 184, 177]
   najnizi = visine[0]
   for visina in visine[1:]:
       if visina < najnizi:
           najnizi = visina
   print(najnizi)

.. infonote::

   Тражење максимума три или четири броја се може засновати и на
   испитивању свих могућих односа тих бројева. На пример,

   .. activecode:: максимум_пешке

      visine = [173, 171, 184, 177]
      if visine[0] >= visine[1] and visine[0] >= visine[2] and visine[0] >= visine[3]:
          najvisi = visine[0]
      if visine[1] >= visine[0] and visine[1] >= visine[2] and visine[1] >= visine[3]:
          najvisi = visine[1]
      if visine[2] >= visine[0] and visine[2] >= visine[1] and visine[2] >= visine[3]:
          najvisi = visine[2]
      if visine[3] >= visine[0] and visine[3] >= visine[1] and visine[3] >= visine[2]:
          najvisi = visine[3]
      print(najvisi)

   .. activecode:: максимум_пешке_1

      visine = [173, 171, 184, 177]
      if visine[0] >= visine[1]:
          if visine[0] >= visine[2]:
              if visine[0] >= visine[3]:
	          najvisi = visine[0]
              else:
	          najvisi = visine[3]
          else:
	      if visine[2] >= visine[3]:
	          najvisi = visine[2]
	      else:
	          najvisi = visine[3]
      else:
          if visine[1] >= visine[2]:
              if visine[1] >= visine[3]:
	          najvisi = visine[1]
              else:
	          najvisi = visine[3]
          else:
	      if visine[2] >= visine[3]:
	          najvisi = visine[2]
	      else:
	          najvisi = visine[3]
		
      print(najvisi)      


   Као што видите, сва ова решења су веома ружна и стога их треба избегавати.

Највећи број лоптица испред Карела
''''''''''''''''''''''''''''''''''
   
.. questionnote::

   Карел се налази испред поља са лоптицама и жели да сазна колики је
   највећи број лоптица на неком од поља испред њега. Број лоптица на
   пољу на којем се налази Карел може сазнати позивом функције
   ``broj_loptica_na_polju()``. Карел тренутно само изговара број
   лоптица на сваком пољу. Поправи програм тако да се исправно
   израчунава највећи број лоптица.
   
.. karel:: карел_тражи_максимум

   
   {
      setup: function() {
	   var world = new World(6, 1);
           world.setRobotStartAvenue(1);
           world.setRobotStartStreet(1);
           world.setRobotStartDirection("E");
	   for (var k = 2; k <= 6; k++)
	          for (var c = 0; c < Math.floor(15*Math.random()); c++)
                     world.putBall(k, 1);
           var robot = new Robot();
	   robot.setInfiniteBalls(true);
	   
	   var code = ["from karel import *",
	                   "maks = 0",
			   "while moze_napred():",
			   "    napred()",
			   "    # zameni narednu liniju tako da se ažurira maksimalni broj loptica",
			   "    izgovori(broj_loptica_na_polju())",
			   "izgovori(maks)"];
	   return {world: world, robot: robot, code: code};
      },

      isSuccess: function(robot, world) {
           var max = 0;
	   for (var k = 2; k <= 6; k++)
	      if (world.getBalls(k, 1) > max)
	        max = world.getBalls(k, 1)
           return max == parseInt(robot.lastMessage);
      }
   }

Џепарац
'''''''
   
Некада нас не занима вредност максимума тј. минимума, већ позиција на
којој се тај максимум тј. минимум налази. Да бисмо то израчунали,
потребно је да уз текућу вредност максимума тј. минимума памтимо и
текућу вредност његове позиције.

.. questionnote::

   Радица је добијала џепарац током пет дана у недељи. Ког дана је
   добила највећи џепарац (ако је то понедељак онда испиши 1, ако је
   то уторак онда 2 и тако даље).

.. activecode:: dzeparac

   dzeparacPon = int(input())
   maksDzeparac = dzeparacPon
   maksDan = 1
   dzeparacUto = int(input())
   if dzeparacUto > maksDzeparac:
       maksDzeparac = dzeparacUto
       maksDan = 2
   dzeparacSre = int(input())
   if dzeparacSre > maks:
       maksDzeparac = dzeparacSre
       maksDan = 3
   dzeparacCet = int(input())
   if dzeparacCet > maks:
       maksDzeparac = dzeparacCet
       maksDan = 4
   dzeparacPet = int(input())
       maksDzeparac = dzeparacPet
       maksDan = 5
   print('MaksDzeparac:', maksDzeparac, 'Dan:', maksDan)

Лепше решење се може добити ако се употреби петља:

.. activecode:: dzeparac_petlja

   maksDzeparac = int(input())
   maksDan = 1
   for dan in range(2, 5):
       dzeparac = int(input())
       if dzeparac > maksDzeparac:
           maksDzeparac = dzeparac
	   maxDan = dan
   print('MaksDzeparac:', maksDzeparac, 'Dan:', maksDan)
   
Пошто су сви износи позитивни, максимум се може иницијализовати на
нулу.  Прилагоди програм тако да коректно одреди тражене податке.

.. activecode:: dzeparac_petlja_0

   maksDzeparac = 0
   for dan in range(1, 5):
       dzeparac = int(input())
       if dzeparac > maksDzeparac:
           maksDzeparac = dzeparac
           maxDan = dan
   print('MaksDzeparac:', maksDzeparac, 'Dan:', maksDan)

Ако се тражи позиција максималне вредности у листи, тада је довољно
памтити само позицију текућег максимума, пошто се текућа вредност
максимума може прочитати из листе када се позиција зна. Потребно је
само обратити пажњу на то да се индекси (позиције елемената) у листи
броје од нуле.

.. activecode:: dzeparci_2

   dzeparci = [250, 300, 250, 200, 150]
   maksDan = 0
   for dan in range(1, 4):
       if dzeparci[dan] > dzeparci[maksDan]:
           maksDan = dan
   print('MaksDzeparac:', dzeparci[maksDan], 'Dan:', maksDan)
   
